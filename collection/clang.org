* linux compile
**  ar 
*** 用法：C:\msys32\mingw32\bin\ar.exe [仿真选项] [-]{dmpqrstx}[abcDfilMNoPsSTuvV] [--plugin <名称>] [成员名] [计数] 归档 文件…
       C:\msys32\mingw32\bin\ar.exe -M [<mri-脚本]
*** 命令：
- d           :: - 从归档文件中删除文件
- m[ab]       :: - 在归档文件中移动文件
- p           :: - 打印在归档文件中找到的文件
- q[f]        :: - 将文件快速追加到归档文件中
- r[ab][f][u] :: - 替换归档文件中已有的文件或加入新文件
- s           :: - 作为 ranlib 工作
- t           :: - 显示归档文件的内容
- x[o]        :: - 从归档文件中分解文件
*** 特定命令修饰符：
-  [a]        ::  - 将文件置于 [成员名] 之后
-  [b]        ::  - 将文件置于 [成员名] 之前 (于 [i] 相同)
-  [D]        ::  - 将 0 用于时间戳和 uid/gid
-  [D]        ::  - 使用实际时间戳和 uid/gid（默认）
-  [N]        ::  - 使用名称的实例 [数量]
-  [f]        ::  - 截去插入的文件名称
-  [P]        ::  - 在匹配时使用完整的路径名
-  [o]        ::  - 保留原来的日期
-  [u]        ::  - 只替换比当前归档内容更新的文件
*** 通用修饰符：
-  [c]         :: - 不在必须创建库的时候给出警告
-  [s]         :: - 创建归档索引 (cf. ranlib)
-  [S]         :: - 不要创建符号表
-  [T]         :: - 产生一个简单归档
-  [v]         :: - 输出较多信息
-  [V]         :: - 显示版本号
- @<file>      :: - 从 <file> 读取选项
-  --target=BFDNAME :: - 指定目标对象格式为 BFDNAME
*** 可选项：
-  --plugin <p> :: - 加载指定的插件程序
*** 仿真选项：
  没有仿真特有的选项
** gcc
** gdb
* C in DSP                                                            :DSP:c:
** volatile
当要求使用volatile声明变量值得时候，系统总是重新从它所在的内存读取数据。
遇到这个关键字声明的变量，编译器对访问变量的代码就不再进行优化，从而可以提供对特殊地质的稳定访问。
volatile关键词异性编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，
与该变量有关的运算，不要进行编译优化，以免出错。

1. volatile的应用场景
   - 中断服务程序中修改的供其他程序检测的变量需要加volatile。
   - 多任务环境下各任务键共享的标志应该加volatile
   - 存储器映射的硬件寄存器通常也要添加volatile，因为每次对它的读写都可能有不同的意义。
     如：对一个设备初始化，对其对应的IO地址做不同的持续系列动作。
2. 疑问
   - 参数可以是const且是volatile吗 ::
        可以，const意味着程序不可以修改变量，volatile意味可能会被意外修改。
   - 指针可以是volatile吗 :: 
                       可以，当中断服务子程序修改一个指向一个buffer的指针时。
3. volatile的本质
   - 编译器的优化 ::
               为提高存储速度，编译器会把内存值读到寄存器中。
               如果变量在本线程外的其他线程中改变了，可能会出现数据不一致的情况。
   - volatile :: 
                 动作为“直接存取原始内存地址”，名称为“易变”。

** restrict
restrict是c99标准引入的，
它只可以用于限定和约束指针，
并表明指针是访问一个数据对象的唯一且初始的方式.即它告诉编译器，
所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,
而不能通过其它途径(其它变量或指针)来修改;
这样做的好处是,
能帮助编译器进行更好的优化代码,
生成更有效率的汇编代码.

